\documentclass[a4paper,12pt]{article}

\input{setup}

%\usepackage{cmap}
%\usepackage[utf8x]{inputenc}
%\usepackage{latexsym}
%\usepackage[danish]{babel}
%\usepackage{graphicx}
\usepackage{graphpap}
%\usepackage{color}
%\usepackage{hyperref}
%\usepackage[all]{hypcap}
%\usepackage{enumerate}
\usepackage{tikz}
\usetikzlibrary{patterns}

\title{Programmering og Problemløsning\\Datalogisk Institut,
  Københavns Universitet\\Arbejdsseddel 7 --- gruppeopgave}

\author{Jon Sporring}
\date{24.\ oktober -- 21.\ november.\\Afleveringsfrist: onsdag d.\ 21.\ november kl. 22:00}

\begin{document}
\maketitle

I denne periode skal I arbejde i grupper.  Formålet er at arbejde med
sumtyper og endelige træer. Opgaverne er delt i øve- og
afleveringsopgaver.
\noindent
I denne periode skal I arbejde i grupper. Formålet er at arbejde med:
\begin{itemize}
%\item strenge
\item rekursion
\item pattern matching
\item sumtyper
\item endelige træer
\end{itemize}


\section*{Øveopgaver}

\dots

% \begin{enumerate}[label=7ø.\arabic*,start=0]
% \item Omskriv funktionen \lstinline{insert}, som benyttes i forbindelse
%   med funktionen \lstinline{isort} (insertion sort) fra forelæsningen,
%   således at den benytter sig af pattern matching på lister.
% \item Omskriv funktionen \texttt{bsort} (bubble sort) fra
%   forelæsningen således at den benytter sig af pattern matching på
%   lister. Funktionen kan passende benytte sig af ``nested pattern
%   matching'' i den forstand at den kan implementeres med et match case
%   der udtrækker de to første elementer af listen samt halen efter
%   disse to elementer.
% \item Opskriv black-box tests for de to sorteringsfunktioner og vær
%   sikker på at grænsetilfældene dækkes (ingen elementer, et element,
%   to elementer, samt flere elementer, sorteret, omvendt sorteret, etc.)

% \item\label{sierpinski.ov} Ved at benytte biblioteket \texttt{ImgUtil}, som beskrevet i
%   forelæsningen, er det muligt at tegne simpel liniegrafik samt
%   fraktaler, som f.eks. Sierpinski-fraktalen, der kan tegnes ved at
%   tegne små firkanter bestemt af et rekursivt mønster. Koden for
%   Sierpinski-trekanten er givet som følger:

% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% open ImgUtil

% let rec triangle bmp len (x,y) =
%   if len < 25 then setBox blue (x,y) (x+len,y+len) bmp
%   else let half = len / 2
%        do triangle bmp half (x+half/2,y)
%        do triangle bmp half (x,y+half)
%        do triangle bmp half (x+half,y+half)

% do runSimpleApp "Sierpinski" 600 600 (fun bmp -> triangle bmp 512 (30,30) |> ignore)
% \end{lstlisting}

% Tilpas funktionen således at trekanten tegnes med røde streger samt
% således at den kun tegnes ned til dybde 2 (hint: du skal ændre betingelsen \lstinline{len < 25}).

% \item\label{sierpinskikeys.ov} I stedet for at benytte funktionen
%   \lstinline{ImgUtil.runSimpleApp} skal du nu benytte funktionen
%   \lstinline{ImgUtil.runApp}, som giver mulighed for at din løsning
%   kan styres ved brug af tastaturet. Funktionen \lstinline{ImgUtil} har følgende type:
% \begin{footnotesize}
% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% val runApp : string -> int -> int
%           -> (int -> int -> 's -> System.Drawing.Bitmap)
%           -> ('s -> System.Windows.Forms.KeyEventArgs
%                  -> 's option)
%           -> 's -> unit
% \end{lstlisting}
% \end{footnotesize}
% De tre første argumenter til \lstinline{runApp} er vinduets titel (en
% streng) samt vinduets initielle vidde og højde. Funktionen
% \lstinline{runApp} er parametrisk over en brugerdefineret type af tilstande (\lstinline{'s}). Antag at funktionen kaldes som følger:
% \begin{footnotesize}
% \begin{lstlisting}[numbers=none,frame=none,mathescape]
%   runApp title width height draw react init
% \end{lstlisting}
% \end{footnotesize}
% Dette kald vil starte en GUI applikation med titlen \lstinline{title},
% vidden \lstinline{width} og højden \lstinline{height}. Funktionen
% \lstinline{draw}, som brugeren giver som 4.\@ argument kaldes initielt
% når applikationen starter og hver gang vinduets størrelse justeres
% eller ved at funktionen \lstinline{react} er blevet kaldt efter en
% tast er trykket på tastaturet. Funktionen \lstinline{draw} modtager
% også (udover værdier for den aktuelle vidde og højde) en værdi for den
% brugerdefinerede tilstand, som initielt er sat til værdien
% \lstinline{init}. Funktionen skal returnere et bitmap, som for
% eksempel kan konstrueres med funktionen \lstinline{ImgUtil.mk} og
% ændres med andre funktioner i \lstinline{ImgUtil}
% (f.eks. \lstinline{setPixel}).

% Funktionen \lstinline{react}, som brugeren giver som 5.\@ argument
% kaldes hver gang brugeren trykker på en tast. Funktionen tager som
% argument en værdi svarende til den nuværende tilstand for
% applikationen samt et argument der kan benyttes til at afgøre hvilken
% tast der blev trykket på.\footnote{Hvis \lstinline{e} har typen
%   \lstinline{System.Windows.Forms.KeyEventArgs} kan betingelsen
%   \lstinline{e.KeyCode = System.Windows.Forms.Keys.Up} benyttes til at
%   afgøre om det var tasten ``Up'' der blev trykket på.} Funktionen kan
% nu (eventuelt) ændre på dens tilstand ved at returnere en ændret værdi
% for denne.

% Tilpas applikationen således at dybden af
% fraktalen kan styres ved brug af piletasterne, repræsenteret ved værdierne
% \lstinline{System.Windows.Forms.Keys.Up} og
% \lstinline{System.Windows.Forms.Keys.Down}.

% \vspace*{5cm}

% I de næste to opgaver skal følgende sum-type benyttes til at
% repræsentere ugedage:

% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% type weekday = Monday | Tuesday | Wednesday | Thursday
%              | Friday | Saturday | Sunday
% \end{lstlisting}

% \item Lav en funktion \texttt{dayToNumber : weekday -> int}, der givet
%   en ugedag returnerer et tal, hvor mandag skal give tallet 1, tirsdag
%   tallet 2 osv.

% \item Lav en funktion \texttt{nextDay : weekday -> weekday}, der givet
%   en ugedag returnerer den næste dag, så mandag skal give tirsdag,
%   tirsdag skal give onsdag, osv, og søndag skal give mandag.
% \end{enumerate}

% I de følgende opgaver (både øveopgaver og
% afleveringsopgaver) skal vi arbejde med en træstruktur til at beskrive geometriske
% figurer med farver.  For at gøre det muligt at afprøve jeres opgaver
% skal I gøre brug af det udleverede bibliotek \texttt{img\_util.dll}, der
% blandt andet kan omdanne såkaldte bitmap-arrays til png-filer.  Biblioteket er
% beskrevet i forelæsningerne (i uge 6) og koden for biblioteket ligger
% sammen med forelæsningsplancherne for uge 6.  Her bruger vi
% funktionerne til at konstruere et bitmap-array samt til at gemme
% arrayet som en png-fil:

% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% // colors
% type color = System.Drawing.Color
% val fromRgb : int * int * int -> color
% // bitmaps
% type bitmap = System.Drawing.Bitmap
% val mk       : int -> int -> bitmap
% val setPixel : color -> int * int -> bitmap -> unit

% // save a bitmap as a png file
% val toPngFile : string -> bitmap -> unit
% \end{lstlisting}

% Funktionen \lstinline{toPngFile} tager som det første argument navnet
% på den ønskede png-fil (husk extension).  Det andet argument er
% bitmap-arrayet som ønskes konverteret og gemt. Et bitmap-array kan
% konstrueres med funktionen \lstinline{ImgUtil.mk}, der tager som
% argumenter vidden og højden af billedet i antal pixels, samt funktionen
% \lstinline{ImgUtil.setPixel}, der kan bruges til at opdatere bitmap-arrayet
% før det eksporteres til en png-fil. Funktionen \lstinline{ImgUtil.setPixel}
% tager tre argumenter. Det første argument repræsenterer en farve og
% det andet argument repræsenterer et punkt i bitmap-arrayet (dvs.\@ i
% billedet). Det tredie argument repræsenterer det bitmap-array, der
% skal opdateres.  En farve kan nu konstrueres med funktionen
% \lstinline{ImgUtil.fromRgb} der tager en triple af tre tal mellem 0 og
% 255 (begge inklusive), der beskriver hhv.\@ den røde, grønne og blå del
% af farven.

% Koordinaterne starter med $(0,0)$ i øverste venstre hjørne og
% $(w-1,h-1)$ i nederste højre hjørne, hvis bredde og højde er hhv.\ $w$
% og $h$.  Antag for eksempel at programfilen \texttt{testPNG.fsx}
% indeholder følgende F\# kode:

% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% let bmp = ImgUtil.mk 256 256
% do ImgUtil.setPixel (ImgUtil.fromRgb (255,255,0)) (10,10) bmp
% do ImgUtil.toPngFile "test.png" bmp
% \end{lstlisting}

% \noindent
% Det er nu muligt at generere en png-fil med navn \texttt{test.png} ved
% at køre følgende kommando:

%   \vspace{-4mm}
% \begin{verbatim}
%   fsharpi -r img_util.dll testPNG.fsx
% \end{verbatim}
%   \vspace{-4mm}

% \noindent
% Den genererede billedfil \texttt{test.png} vil indeholde
% et sort billede med et pixel af gul farve i punktet (10,10).

% \noindent
% Bemærk, at alle programmer, der bruger \texttt{ImgUtil} skal køres
% eller oversættes med \texttt{-r img\_util.dll} som en del af
% kommandoen.
% %
% Bemærk endvidere, at \LaTeX\ kan inkludere png-filer med
% kommandoen \texttt{includegraphics}.

% \vspace{2ex}

% \noindent
% I det følgende vil vi repræsentere geometriske figurer med følgende
% datastruktur:

% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% type point = int * int // a point (x, y) in the plane
% type colour = int * int * int  // (red, green, blue), 0..255

% type figure =
%   | Circle of point * int * colour
%      // defined by center, radius, and colour
%   | Rectangle of point * point * colour
%      // defined by corners bottom-left, top-right, and colour
%   | Mix of figure * figure
%      // combine figures with mixed colour at overlap
% \end{lstlisting}

% \noindent
% For eksempel kan man lave følgende funktion til at finde farven af en
% figur i et punkt.  Hvis punktet ikke ligger i figuren, returneres
% \texttt{None}, og hvis punktet ligger i figuren, returneres
% \texttt{Some $c$}, hvor $c$ er farven.

% \begin{lstlisting}[numbers=none,frame=none,mathescape]
% // finds colour of figure at point
% let rec colourAt (x,y) figure =
%   match figure with
%   | Circle ((cx,cy), r, col) ->
%       if (x-cx)*(x-cx)+(y-cy)*(y-cy) <= r*r
%         // uses Pythagoras' formular to determine
%         // distance to center
%       then Some col else None
%   | Rectangle ((x0,y0), (x1,y1), col) ->
%      if x0<=x && x <= x1 && y0 <= y && y <= y1
%         // within corners
%      then Some col else None
%   | Mix (f1, f2) ->
%       match (colourAt (x,y) f1, colourAt (x,y) f2) with
%       | (None, c) -> c  // no overlap
%       | (c, None) -> c  // no overlap
%       | (Some (r1,g1,b1), Some (r2,g2,b2)) ->
%          // average color
%          Some ((r1+r2)/2, (g1+g2)/2, (b1+b2)/2)
% \end{lstlisting}

% \noindent
% Bemærk, at punkter på cirklens omkreds og rektanglens kanter er med i
% figuren.  Farver blandes ved at lægge dem sammen og dele med to, altså
% finde gennemsnitsfarven.

% \begin{minipage}{.72\textwidth}
% \begin{enumerate}[label=7ø.\arabic*,start=2]

% \item Lav en figur \texttt{figTest : figure}, der består af en rød cirkel
%   med centrum i (50,50) og radius 45, samt en blå rektangel med
%   hjørnerne (40,40) og (90,110), som illustreret i tegningen til
%   højre (hvor vi dog har brugt skravering i stedet for udfyldende farver.)

% \item Brug \texttt{ImgUtil}-funktionerne og \texttt{colourAt} til at lave en
%   funktion

%   \vspace{-4mm}
% \begin{verbatim}
% makePicture : string -> figure -> int -> int
%            -> unit
% \end{verbatim}
%   \vspace{-4mm}

% \noindent
% sådan at kaldet \texttt{makePicture \emph{filnavn figur b h}} laver en
% billedfil ved navn \texttt{\emph{filnavn}.png} med et billede af
% \texttt{\emph{figur}} med bredde \texttt{\emph{b}} og højde
% \texttt{\emph{h}}.

% På punkter, der ingen farve har (jvf.\ \texttt{colourAt}), skal farven
% være grå (som defineres med RGB-værdien (128,128,128)).

% Du kan bruge denne funktion til at afprøve dine opgaver.
% \end{enumerate}
% \end{minipage}\hspace{4mm}\begin{minipage}{.23\textwidth}

% \begin{tikzpicture}[domain=0:12,scale=0.25]
%     \draw[very thin,color=gray] (0,0) grid (10,12);
%     \draw[->] (0,12) node[left] {$0$} -- (11,12) node[right] {$x$};
%     \draw[->] (0,12) node[above] {$0$} -- (0,-1) node[below] {$y$};
%     \draw[-] (5,12) node[above] {$50$} -- (5,0);
%     \draw[-] (10,12) node[above] {$100$} -- (10,0);
%     \draw[-] (0,7) node[left] {$50$} -- (10,7);
%     \draw[-] (0,2) node[left] {$100$} -- (10,2);
%     \draw[pattern=north west lines, pattern color=red] (5,7) circle (4.5);
%     \draw[pattern=north east lines, pattern color=blue] (4,1) rectangle (9,8);
% \end{tikzpicture}

% \end{minipage}

% \begin{minipage}{.72\textwidth}
% \begin{enumerate}[label=8ø.\arabic*,start=4]
% \item Lav med \texttt{makePicture} en billedfil med navnet
%   \texttt{figTest.png} og størrelse $100\times150$ (bredde 100, højde 150),
%   der viser figuren \texttt{figTest} fra opgave 8ø.2.

%   Resultatet skulle gerne ligne figuren til højre.

% \item Lav en funktion \texttt{checkFigure : figure -> bool},
%   der undersøger, om en figur er korrekt: At radiusen i cirkler
%   er ikke-negativ, at øverste venstre hjørne i en rektangel faktisk
%   er ovenover og til venstre for det nederste højre hjørne (bredde og
%   højde kan dog godt være 0), og at farvekompenterne ligger mellem 0
%   og 255.

%   Vink: Lav en hjælpefunktion \texttt{checkColour : colour -> bool}.
% \end{enumerate}

% \end{minipage} \hfill \begin{minipage}{.2\textwidth}
%   \includegraphics[width=0.9\textwidth]{figTest.png}
% \end{minipage}

% \begin{minipage}{.72\textwidth}
% \begin{enumerate}[label=8ø.\arabic*,start=6]
% \item Lav en funktion \texttt{move : figure -> int * int ->
%   figure}, der givet en figur og en vektor flytter figuren langs
%   vektoren.

%   Ved at foretage kaldet
% \begin{verbatim}
% makePicture "moveTest" (move figTest (-20,20)) 100 150
% \end{verbatim}
%   shulle der gerne laves en billedfil \texttt{moveTest.png}
%   med indholdet vist til højre.

% \item Lav en funktion \texttt{boundingBox : figure -> point *
%   point}, der givet en figur finder hjørnerne (top-venstre og
%   bund-højre) for den mindste akserette rektangel, der indeholder hele
%   figuren.

%   \texttt{boundingBox figTest} skulle gerne give \texttt{((5, 5), (95,
%     110))}.

% \end{enumerate}

% \end{minipage} \hfill \begin{minipage}{.2\textwidth}
% \includegraphics[width=0.9\textwidth]{moveTest.png}
% \end{minipage}

\section*{Afleveringsopgave}
I denne opgave skal I programmere spillet Awari, som er en variant af
Kalaha. Awari er et gammelt spil fra Afrika, som spilles af 2
spillere, med 7 pinde og 36 bønner. Pindende lægges så der dannes 14
felter ('pit' på engelsk), og bønnerne fordeles ved spillet start med 3 i hver af
felterne, som ikke er hjemmefelterne. Dette er illustreret i
Figur~\ref{fig:awari}.
\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{awari.pdf}
  \caption{Udgangsopstillingen for spillet Awari.}
  \label{fig:awari}
\end{figure}

Spillerne skiftes til at spille en tur efter følgende regler:
\begin{itemize}
\item En tur spilles ved at spilleren tager alle bønnerne i et af
  spillerens felter 1-6 og placerer dem i de efterfølgende felter
  inkl. hjemmefelterne en ad gangen og mod uret. F.eks., kunne første
  spiller vælge at tage alle 3 bønner fra felt 4 og skulle derefter
  placere en bønne i hver af felterne 5, 6 og hjemmefeltet.
\item Hvis sidste bønne lægges i spilleres hjemmefelt, får spilleren
  en tur til.
\item Hvis sidste bønne lander i et tom felt pånær hjemmefelterne, og
  feltet overfor indeholder bønner, så flyttes sidste bønne til
  hjemmefeltet, og alle bønnerne overfor fanges og flyttes ligså til
  hjemmefeltet.
\item Spillet er slut når en af spillerne ingen bønner har i sine
  felter 1-6, og vinderen er den spiller, som efter spillets
  afslutning har flest bønner i sit hjemmefelt.
\end{itemize}
Afleveringsopgaven er:
\begin{enumerate}[label=7g.\arabic*,start=0]
\item I skal implementere spillet Awari, som kan spilles af 2
  spillere, og skrive en kort rapport. Kravene til jeres aflevering
  er:
  \begin{itemize}
  \item I skal bruge rekursion, sumtyper (discriminated unions), og
    Option typer. Jeres løsning kan f.eks.\ bygges op efter følgende skelet:
     \begin{verbatimwrite}{src/7gSkeleton.fsx}
// Initial board, first 7 is player 1's 1-6 and home,
// second 7 is player 2's
let board = [|3;3;3;3;3;3;0;3;3;3;3;3;3;0|]
type player = Player1 | Player2

/// Print the board, player 1 is bottom row and rightmost
/// home.
let printBoard (board : int []) : unit =
  ...

/// Convert from user's coordinates to board's coordinates.
/// Players enters 1-6 corresponding to board index 0-5
/// or 7-12
let pit2ind (p : player) (pit : int) : int =
  ...

/// True if either side has no beans
let isGameOver (board : int []) : bool =
  ...

/// True if board index is the players home
let isHome (p : player) (ind : int) : bool =
  ...

/// Get the index of next move. User must enter a pit
/// number between 1-6 corresponding to a
/// non-empty board index
let rec getMove (p : player) (str : string) : int option =
  ...

/// Updates board by distributing beans counter clockwise,
/// capturing when relevant. Board coordinate of last bean
/// is returned. Sideeffect warning!
let distributeNUpdate (board : int []) (ind : int) : int =
  ...
     \end{verbatimwrite}
    \fsCode{7gSkeleton}{7gSkeleton}{Testing.}{}
    \item Koden skal dokumenteres vha.\ kommentarstandarden for F\#
    \item Jeres aflevering skal indeholde en afprøvning efter white-box metoden.
    \item I skal skrive en kort rapport i LaTeX  på maks.\ 10 sider og
      som indeholder:
      \begin{itemize}
      \item en beskrivelse af jeres design og implementation
      \item en gennemgang af jeres white-box afprøvning
      \item kildekoden som appendiks.
      \end{itemize}
  \end{itemize}
\end{enumerate}

Afleveringen skal bestå af en zip-fil og en pdf-fil. Zip-filen skal
indeholde en mappe med fsharp koden. Koden skal kunne oversættes med
fsharpc og køres med mono. Hvis der er flere filer, skal der være en
kort beskrivelse af, hvordan man kører
programmet/programmerne. Pdf-filen skal indeholde jeres LaTeX rapport
oversat til pdf.

\end{document}

