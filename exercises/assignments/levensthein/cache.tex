Den direkte implementerede rekursive funktion er temmelig
    ineffektiv når strengene $a$ og $b$ er store. F.eks. tager det en
    del millisekunder at udregne distancen mellem strengene
    ``dangerous house'' and ``danger horse''. Årsagen til denne
    ineffektivitet er at en løsning der bygger direkte på den
    rekursive definition resulterer i en stor mængde genberegninger af
    resultater der allerede er beregnet.

    For at imødekomme dette problem skal du implementere en såkaldt
    ``caching mekanisme'' der har til formål at sørge for at en
    beregning højst foretages en gang.  Løsningen kan passende gøre
    brug af gensidig rekursion og tage udgangspunkt i løsningen for
    den direkte rekursive definition (således skal løsningen nu
    implementeres med to gensidigt rekursive funktioner \lstinline{leven} og \lstinline{leven_cache} forbundet med
    \lstinline{and}). Som cache skal der benyttes et 2-dimensionelt
    array af størrelse $|a|\times|b|$ indeholdende heltal (initielt
    sat til $-1$).

    Funktionen \lstinline{leven_cache}, der skal tage tilsvarende
    argumenter som \lstinline{leven}, skal nu undersøge om der
    allerede findes en beregnet værdi i cachen, i hvilket tilfælde
    denne værdi returneres. Ellers skal funktionen \lstinline{leven}
    kaldes og cachen opdateres med det beregnede resultat. Endelig er
    det nødvendigt at funktionen \lstinline{leven} opdateres til nu at
    kalde funktionen \lstinline{leven_cache} i hver af de rekursive kald.

    Test funktionen på de små strenge og vis at funktionen nu virker
    korrekt også for store input.

    Det skal til slut bemærkes at den implementerede løsning benytter
    sig af $O(|a| \times |b|)$ plads og at der findes effektive
    løsninger der benytter sig af mindre plads
    ($O(\mathrm{max}(|a|,|b|))$). Det er ikke et krav at din løsning
    implementerer en af disse mere pladsbesparende strategier.