In the following, you are to implement your own queue module using lists in F\# to represent the (sequence of elements in) a queue. The module is to be called \lstinline{IntQueue}.
\begin{enumerate}
\item Given the description of the abstract datatype Queue above, write a signature file \texttt{intQueue.fsi} for the functional queues. 
\item Write an implementation file \texttt{intQueue.fs}, implementing the signature file above using lists in F\# where the elements are F\# integers.
\item Add \texttt{intQueue.fsi} and \texttt{intQueue.fs} to \texttt{5i.fsproj},\\so they are compiled \textit{before} \texttt{testQueues.fs}.
\item In \texttt{testQueues.fs}, show your implementation works by using your queue. As a minimum, you should add the following series of tests of your \texttt{IntQueue} module:
\newline
{\textcolor{red}{changed from v1: negate the result of \texttt{IntQueue.isEmpty q1} so \texttt{nonEmptyTestResult} is \texttt{true} when the implementation of \texttt{IntQueue.isEmpty} is correct.}}
\begin{lstlisting}
let intQueueTests () =
    let q0 = IntQueue.emptyQueue
    let emptyTestResult = IntQueue.isEmpty q0
    emptyTestResult
    |> printfn "An empty queue is empty: %A"

    let e1,e2,e3 = 1,2,3
    let q1 = q0 |> IntQueue.enqueue e1
                |> IntQueue.enqueue e2
                |> IntQueue.enqueue e3
    let nonEmptyTestResult = not (IntQueue.isEmpty q1)

    nonEmptyTestResult
    |> printfn "A queue with elements is not empty: %A"

    let (e,q2) = IntQueue.dequeue q1
    let dequeueTestResult = e = e1
    dequeueTestResult
    |> printfn "First in is first out: %A" 

    let allTestResults =
        emptyTestResult &&
        nonEmptyTestResult &&
        dequeueTestResult

    allTestResults
    |> printfn "All IntQueue tests passed: %A"
    // Return the test results as a boolean
    allTestResults

// Run the IntQueue tests
let intQueueTestResults = intQueueTests ()

\end{lstlisting}
\end{enumerate}
