\section*{File concatenation}

The \texttt{cat}-utility from 
Unix\footnote{Unix is the predecessor operating system for MacOS, Linux and most server operating system in current practical use.} 
is a program that concatenates files.  
This exercise is about building a \texttt{cat}-like program in F\# in a file called \texttt{cat.fs} that contains the following functions, plus additional definitions as you see fit to solve this exercise.

We recommend that you create a new dotnet project using \texttt{dotnet new console -lang "F\#" -o cat}, then create the files \texttt{Cat.fsi} and \texttt{Cat.fs} and add them to \texttt{cat.fsproj}.


You can then use the following \textit{skeletons} for the three files:

\begin{itemize}
\item \textbf{Cat.fsi} \\
  \begin{lstlisting}{fsharp}
module Cat
open System.IO

val readBytes: FileStream -> byte[]
val readFile: string -> byte[]
val readFiles: string list -> byte[] option list
val writeBytes: byte[] -> FileStream -> unit
val writeFile: byte[] -> string -> int
val cat: string[] -> int
  \end{lstlisting}
\item \textbf{Cat.fs} \\
  \begin{lstlisting}{fsharp}
module Cat
open System.IO

let readBytes (fs:FileStream) : byte[] =
    [||] // Replace this with a proper implementation

let readFile (filename:string) : byte[] =
    [||] // Replace this with a proper implementation

let readFiles (filenames : string list) : byte[] option list =
    [] // Replace this with a proper implementation

let writeBytes (bytes : byte[]) (fs:FileStream) =
    () // Replace this with a proper implementation

let writeFile (bytes: byte[]) (filename:string) =
    0 // Replace this with a proper implementation

let cat (filenames : string[]) =
    0 // Replace this with a proper implementation
  \end{lstlisting}
\item \textbf{Program.fsx} \\
  \begin{lstlisting}{fsharp}
open Cat

[<EntryPoint>]
let main (args : string[]) =
    // args is a string array
    // containing the command-line arguments
    printfn "%A" args 
    0 // The exit code, 0 means "all is good"
  \end{lstlisting}
\end{itemize}



\subsection*{Reading contents of file stream}

Write function \texttt{readBytes: fs:FileStream -> byte[]} with the following specification.  
\begin{itemize}
\item Precondition: \texttt{fs} is a readable file stream.
\item Postcondition: For \texttt{bs = readBytes fs}, the byte array \texttt{bs} contains the entire contents of the file stream.   
\end{itemize}

You should create a byte array of a suitable size and use \texttt{FileStream.Read((buffer:byte[]), (offset:int32), (count:int32))} to read the file contents into the array before returning it.

\subsection*{Reading contents of file}

Implement a function \texttt{readFile: filename:string -> byte[]} with the following specification. 
\begin{itemize}
\item Precondition: None (any string is acceptable and must be handled)
\item Postcondition: If the input string is a readable file, return its contents.  Otherwise raise exception \texttt{FileNotFoundException} if the file does not exist or is not readable.
\end{itemize}

The function should obtain a \texttt{FileStream}, e.g. through \texttt{File.OpenRead}, and use your \texttt{readBytes} to read the filestream.

Note: While it is possible to implement this function using \texttt{File.ReadAllBytes}, the intended learning goal of this exercise is how to \textit{implement your own version}.

\subsection*{Reading contents of multiple files}
 
Implement a function \texttt{readFiles: (filenames:string list) -> byte[] option list} with the following specification:
\begin{itemize}
\item Precondition: None (any list of strings is acceptable and must be handled)
\item Postcondition: For each string in the input, the output is either the contents of the file with that name (wrapped in \texttt{Some}), if the file exists and is readable; otherwise it is \texttt{None}.  
\end{itemize}

\subsection*{Writing bytes to a file stream}

Write function \texttt{writeBytes: (bytes:byte[]) (fs:FileStream) -> unit} with the following specification.  
\begin{itemize}
\item Precondition: \texttt{bytes} is a byte array and \texttt{fs} is a readable file stream.
\item Postcondition: all bytes in \texttt{bytes} are written to \texttt{fs}.
\end{itemize}

\subsection*{Writing bytes to file}

Implement a function \texttt{writeFile: (bytes:byte[]) (filename:string) -> int} with the following specification. 
\begin{itemize}
\item Precondition: \texttt{bytes} is a byte array.
\item Postcondition: All bytes in \texttt{bytes} are written to the file \texttt{filename}. If \texttt{filename} does not exist, it is created. If it does exist, it is overwritten with the contents of \texttt{bytes}. The exit status is 0.
  If an error occurs, the string \verb|cat: Could not open or create file | \textit{filename} \verb|.\n| is written to stderr. The exit status is 1.
\end{itemize}

The function should obtain a \texttt{FileStream} and use \texttt{writeBytes} to write the bytes to the filestream. 
You should use \texttt{File.Open} with an appropriate \texttt{FileMode}. 
You might need to call the \texttt{Flush()} method on your \texttt{FileStream} after writing bytes to it. 

\subsection*{Concatenating file contents and writing to files}

Implement a function \texttt{cat: (filenames:string[]) -> int} that outputs to the last \texttt{filename} in \texttt{filenames} the concatenation of the contents of all files in the input array except for the last, in the sequence they occur. Its specification is as follows.
\begin{itemize}
\item Precondition: None (any array of strings is acceptable and must be handled).
\item Postcondition: 
\begin{itemize}
\item If all of the input files exist and are readable, the output written to the last \texttt{filename} contains their concatenated contents in the order given in the input array. Nothing is written to stderr and the exit status (result of the function) is $0$.
\item If one or more of the files does not exist or is not readable, then
  nothing is written to the last \texttt{filename}. The exit status is $k$ where $k$ is the minimum of 255 and the number of nonexistent/unreadable files. For each string $s$ that is a nonexistent/unreadable file, the string \\ \verb|cat: The file | $s$ \verb|does not exist or is not readable.\n| \\ is written to stderr.
\item If \texttt{filenames} contain a single element, that file is either created or overwritten with nothing. The concatenation of ``nothing'' is the empty string.
  \item If \texttt{filenames} is empty, the string \verb|cat: no input files\n| is written to stderr. The exit status is 0. 
\end{itemize}
\end{itemize} 

\subsection*{Putting it all together}

In \texttt{Program.fs} call \texttt{cat} with the command line arguments.

\texttt{dotnet run file1.txt file2.txt file3.txt} should result in \texttt{file3.txt} being either created or overwritten, and should contain the concatenated contents of \texttt{file1.txt} and \texttt{file2.txt}.

\subsection*{Specification-based testing of functions}

Add test cases to the test cases given % \comment{(To be added)}
such that each part of the specifications is covered and such that  extremal values of inputs are considered, such as empty files (files that exist and are readable, but contain zero bytes).   In particular, test your implementation of \texttt{cat}.
