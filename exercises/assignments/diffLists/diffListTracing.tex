Rewriting can help correctly derive more efficient code or just code that may be more easily understandable in terms of more elementary operations.

Consider the extremely compact linear-time implementation for computing the preorder of a binary tree:
\begin{lstlisting}{fsharp}
type 'a tree = Empty | Leaf of 'a | Branch of 'a tree * 'a * 'a tree
open DiffList // nil, single, append, fromDiffList
let combinePre (dl1, x, dl2) = 
    append (single x) (append dl1 dl2)
let preorder' (t : 'a tree) : 'a difflist =
    treeFold (nil, single, combinePre) t
let preorder (t : 'a tree) : 'a list = 
    fromDiffList (preorder' t)
\end{lstlisting}
using difference list.

% \newpage 
Rewrite \verb|preorder'| starting with the definition
\begin{lstlisting}{fsharp}
let preorder' (t : 'a tree) (xs : 'a list) : 'a list =
    match t with
      Empty -> 
         treeFold (nil, single, combinePre) Empty xs
    | Leaf x -> 
         treeFold (nil, single, combinePre) (Leaf x) xs 
    | Branch (t1, x, t2) -> 
         treeFold (nil, single, combinePre) (Branch (t1, x, t2)) xs 
\end{lstlisting}
by first \emph{unfolding} the occurrences of \verb|treeFold|, that is replacing it with its definition; then inlining \verb|nil|, \verb|single|, \verb|combinePre|, \verb|append| until all these occurrences are eliminated; and finally \emph{folding} occurrences of \verb|treeFold (nil, single, combinePre)|, that is replacing them by \verb|preorder'|. 

Finally, do the same for \verb|preorder| by inlining \verb|fromDiffList|, thus eliminating all occurrences of difference list operations.
(See DiffList.fs for the definitions of difference list operations.) 
